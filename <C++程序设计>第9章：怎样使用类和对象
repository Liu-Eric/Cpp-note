===================================构造函数=====================================
构造函数
利用构造函数对类对象初始化
如果一个类的对象都是公有对象，可以通过class obj = {x,x,x}的形式赋值。
c++提供构造函数来处理对象初始化，构造函数是特殊的成员函数，与类名同名，没有返回值，在类对象创建时主动调用，不可以人为调用。
可以通过一个类对象初始化另一个类对象，class obj2 = obj1
如果没有定义构造函数，c++会自动定义一个默认构造函数，函数体为空。
构造函数声明定义：
class Box:
  {public:
    Box(int h, int w, int l):hight(h), weight(w), lenght(l){}; #使用参数化列表创建构造函数，也可以写在普通函数体中
    Box(int h, int w, int l = 10):hight(h), weight(w), lenght(l){}; #带默认参数的构造函数
  private:
    int height;
    int wight;
    int lenght;
#不需要参数的构造函数称为默认构造函数，默认构造函数只能有一个。
#如果有数据成员为数组，则不能用参数化列表的方式，必须在构建函数函数体内赋值。
#构造函数可以通过重载的方式建立不同赋值情况的构造函数。
#默认参数需要在函数声明时定义
===================================析构函数=====================================
在对象的生命期结束时，会自动调用析构函数，析构函数并不删除对象或者释放内存空间，而是在这些之前完成一些清理工作，执行用户在最后一次使用对象之后所希望执行的操作。
析构函数没有返回值，返回类型，没有参数，不能被重载，智能有一个析构函数。
如果没有定义一个析构函数，C++会自动顶一个默认析构函数，函数体为空。
析构函数调用的四种情况：
1.函数内对象在函数函数执行完成后。
2.函数内static对象在主程序完成后。
3.全局对象在主程序完成后。
4.通过new创建的对象在delete后。
在同一作用域范围内，析构函数的调用顺序与构造函数相反。
===================================类对象数据=====================================
创建方式class_name list_name [x]
初始化方式：
class l [3]  = {class(x,x,x), class(y,y,y), class(z,z,z)}
===================================对象指针=====================================
对象指针就是指向类对象的指针，定义形式为：类名 * 对象指针名。
通过对象指针访问对象和对象成员：
* pt/ (*pt.attr) / pt->attr/ (*pt).func() / pt->func()
指向对象数据成员的指针（公有数据对象） 定义形式为； 数据类型名 * 指针名
指向成员函数的指针 定义形式： 数据类型名（类名：：*指针名）（参数列表），赋值方式：指针名 = &类名：：成员函数
在每一个成员函数中都包含一个特殊的指针，指针名称是固定的：this，它是指向本类对象的指针，它的值是当前被调用的成员函数所在类对象的起始地址。
成员函数不存放在类对象的空间中，而存放在类对象之外，由this指针表示是哪一个对象调用。
this指针在成员函数中隐式调用。
===================================共有数据的保护=====================================
常对象是定义时加const定义的对象， 形式为：类名 const对象名（初始化参数），或者const 类名 对象名（初始化参数）。
在常对象生命周期中，所有数据成员的值都不可以修改，常对象只能调用其常成员函数，不能调用普通成员函数。
常成员函数是只能引用类成员，不能改变类成员的函数，声明：返回类型 函数名（）const，声明和定义时都需要加const，调用时不需要。
常成员函数可以访问常const和非const对象成员。
如果一定要修改常对象成员，可以将该成员定位为mutable。
常对象成员是声明为const的对象成员，形式为：const 数据类型 成员名。
常对象成员只能通过参数初始化列表进行初始化，不能在函数体内赋值初始化。
常对象的成员数据都是常对象成员，因此只能参数初始化列表对成员初始化。
常对象成员可以被const函数引用，也可以被非const函数引用。
常指针是将指针对象声明为const，这样这个指针始终保持初值，不能改变，即其指向不变。声明方式：类名 *const 指针变量名
常指针指向对象不变，但可以改变其指向的对象。
指向常对象的指针，定义形式为：const 类型名 *指针变量名
如果一个对象是常对象，则只能用指向常对象的指针指向它。
指向常对象的指针也可以指向未被声明const的对象，但不能通过指针改变对象。指向非const的指针只能指向非const对象。
函数的形参包含指向非const对象的指针，则实参只能是指向非const对象的指针，不能是指向const对象的指针。
如果一个对象已经被声明为常对象，则只能有指向常对象的指针指向它。
指向常对象的指针用于形参，用以保护形参所指向的对象不被改变。
对象的常引用就是对象的别名，实际是一个指针常量，用以存放地址，常引用保护对象不被修改。
const class &obj_1 = obj_2：obj_1是obj_2的引用。
===================================对象的动态建立和释放=====================================
使用new运算符动态创建对象，使用delete运算符注销对象。
执行new语句时，程序开辟一段内存空间，创建类对象并且初始化。new运算符返回指向对象的地址，用户只能通过地址来访问对象。
如果执行new操作时，内存空间不足，会返回0指针。
===================================对象的赋值和复制=====================================
对象之间可以通过“=”赋值运算，这是通过对赋值运算符重载实现的。
class obj_1, obj_2
obj_1 = obj_2
对象赋值只是对象成员的赋值，将一个对象成员的存储空间状态复制给另一个对象的存储空间，与对象函数没有关系，不同对象间享有相同的对象成员函数。
类的对象成员不能包括动态分配的数据。
类对象初始化时可以通过另一个同类对象，会调用特殊的构造函数，复制构造函数,复制构造函数只有一个参数，本类对象的引用。
复制构造函数 class::obj(const obj &b)
class obj_1(obj_2)
系统会默认定义一个复制成员函数，其作用就是简单的对象成员复制。
当函数的形参是类对象时，形参转实参时，会调用对象复制函数，当函数返回对象时，函数结束时，会调用复制函数创建一个临时对象传给函数调用处。
复制是一个对象创建时调用，赋值时一个对象已经存在，改变其内容时调用。
===================================静态成员=====================================
静态成员是所有类对象公有的成员，所有对象的值是一样的，静态成员只在内存中保存一份。
静态成员以static开头。
静态成员在所有类对象以外单独开辟内存空间，只要定义了静态成员，即使没有类对象，也可以引用静态成员。静态成员在程序开始运行时分配空间，程序结束后收回空间。
静态成员只能在类外初始化：数据类型 类名:: 静态对象 = 初始值
静态成员既可以通过类名引用，也可以通过对象引用。
静态成员函数定义： static 返回对象 函数名（）
静态成员函数属于类，可以通过类名和对象调用。静态成员函数不属于对象，没有this指针，不能访问对象成员。
静态成员函数用以处理静态成员
公有成员函数可以访问静态成员。
===================================友元=====================================
如果在类外定义的函数，在类中用friend声明，则此函数称为本类的友元，可以本类的私有成员。
友元函数访问类私有对象时，需要加上对象名称。
提前声明：在正式声明一个类前，先声明一个类名，表示此类稍后声明，别的类声明可以使用先声明类的指针。
一个类可以声明为另一个类的友元类，此类中所有函数都是第二个类的友元函数。
友元是单向关系。
===================================类模板=====================================
template <class 类型参数名>
类模板包含参数类型，称为参数化的类，类模板是类的抽象。
使用：类模板名 <实际类型名> 对象名 （参数表）
成员函数在类模板以外定义形式： template 类名  <typename>:: 函数名（）
类模板可以有多个参数： template <class T1, class T2>






